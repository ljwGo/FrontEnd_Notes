[toc]
# 0. 序言

​	该笔记记录**从浏览器输入域名后到浏览器显示网页页面的全过程**. 注意该过程是谷歌浏览器内核过程.

​	参考[【干货】浏览器是如何运作的？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.1391.0.0&vd_source=adc8614d6ca1140f400db0450edf8018)

# 1. 浏览器

## 1.1 进程策略

​		谷歌浏览器有多种进程策略. 为了**防止单一页面故障阻塞整个浏览器**, 常用的策略是每个页面新建一个单独的进程, 彼此隔离. 这种策略被称为**单一页面单一进程**. 除此之外还有**同一站点单一进程**, **完全单一进程**等.

## 1.2 进程种类

​		为了保证浏览器功能的正常执行. 有多个进程相互协调工作. 这其中包括:

* 用户界面: 控制浏览器标签页, 比如前进, 倒退, 浏览器地址等.
* 浏览器进程: **控制浏览器标签页外的用户界面**. 并协调其它进程顺利进行工作. 它似乎还是数据持久化层.
* 缓存进程: 控制站点缓存
* 网络进程: 浏览器使用它发起网络请求
* GPU进程: 负责渲染页面
* 插件进程: 负责管理安装的插件, 比如flash. 与扩展不同.
* **渲染进程:** 每个页面使用的进程就是渲染进程. **渲染进程中的主线程还是JavaScript的执行线程**.

## 1.3 页面获取

​		地址栏输入地址后, 浏览器分析它是搜索还是域名, 搜索则使用内置的服务地址.域名经过DNS解析为ip, 服务器返回html文件.

# 2. 解析html

​		浏览器解析html.

## 2.1 解析html为dom

​		从上往下通过词法解析html, **遇到js脚本将停止dom解析**(因为js可能改变html). 可以使用async异步加载js.解析html时, 同时加载css, 图片, script等资源. **将html解析为dom, dom是一种数据结构**, 它是面向开发人员, 提供可以访问和修改的api. 

## 2.2 样式计算

​		为每个dom计算它的样式, 比如颜色, 宽度等.

## 2.3 layout布局

​		**计算每个元素应该绘制的位置(x, y).**

## 2.4 绘制顺序表

​		**根据元素的z-index生成绘制顺序表**. 其中, layout布局中每个子节点和dom中的不一一对应.比如display: none在layout树中不存在, ::before伪元素在layout中则存在.

## 2.5 layer层级树

​		根据前面的layout树和绘制顺序表, 将所有元素进行分层. 渲染时将多个层分别渲染, 最后合并成一个画面帧.

# 3. 渲染过程

​		得到layer层级后,主线程就可以将渲染任务交给**合成器线程了**, 合成器线程将每一层进行**分块**, 并将这些分片交给**栅格线程**进程渲染, 渲染结果保存在GPU内存中(滚动画面时复用). 最后合成器线程收集**Draw Quads**并生成画面帧. 

​		通过IPC管道, 将数据从渲染器进程交给GPU进程, 最后显示画面.

## 3.1 重排和重绘

​		触发2.2, 2.3, 2.4, 2.5为重排, 比如修改某个元素的宽高.

​		触发2.2, 2.4为重绘, 比如修改某个元素的颜色.

# 4. JavaScript阻塞主线程

​		重排重绘和JavaScript的执行都依赖于主线程,因此长时间JavaScript会阻塞页面交互, 样式计算等.

## 4.1 requestAnimationFrame

​		requestAnimationFrame的作用类似**周期窃取**, 它允许**Javascript在每帧的最后执行固定时间**.

## 4.2 Transform

​		css的Transform属性运行在合成器线程中, 因此不会阻塞主线程.不会触发重绘和重排.
